?start: expr_list

?expr_list: terminated_expr [expr_list]
?label: name COLON [newlines]
?terminated_expr: [label] [expr] terminator
?expr: exit_expr

?exit_expr: exit_type [exit_value] [exit_direction]
          | assign
?exit_value: [newlines] assign
?exit_type: RETURN
          | YIELD
          | CONTINUE
          | BREAK
          | LEAVE
          | DEFER

?exit_direction: [newlines] TO [newlines] name

?type_expr: COLON [newlines] arith
?assign: primary [newlines] [type_expr] assignop [newlines] group
       | group

?group: starred_expr more_group [COMMA]
      | starred_expr
?more_group: [newlines] COMMA [newlines] starred_expr [more_group]

?starred_expr: single_star_expr
             | double_star_expr
             | block

?single_star_expr: STAR block
?double_star_expr: STAR_STAR block

?block: OPEN_BRACE expr_list CLOSE_BRACE
      | control

?control: control_exprs
        | arith
?control_exprs: if
              | for
              | while
?cond_body: [newlines] expr [elexpr_or_else]
?if: IF expr cond_body
?elif: ELIF expr cond_body

?for_expr: expr IN expr
?for: FOR for_expr cond_body
?elfor: ELFOR for_expr cond_body

?while: WHILE expr cond_body
?elwhile: ELWHILE expr cond_body

?elexpr_or_else: [newlines] elexpr_or_else_real
?elexpr_or_else_real: elexpr | else
?elexpr: elif | elfor | elwhile

?else: ELSE [newlines] expr

// This bit is largely cribbed from https://docs.python.org/3/reference/grammar.html
?arith: disjunction
?disjunction: conjunction more_disjunction
            | conjunction
?more_disjunction: or conjunction [more_disjunction]
?conjunction: inversion more_conjunction
            | inversion
?more_conjunction: and [more_conjunction]
?inversion: not inversion
          | comparison
?comparison: bitwise_or comp_op_bitwise_or
           | bitwise_or
?comp_op_bitwise_or: comp_op bitwise_or [comp_op_bitwise_or]
?bitwise_or: bitwise_or bor bitwise_xor
           | bitwise_xor
?bitwise_xor: bitwise_xor bxor bitwise_and
            | bitwise_and
?bitwise_and: bitwise_and band shift_expr
            | shift_expr
?shift_expr: shift_expr shift_op sum
           | sum
?sum: sum sum_op term
    | term
?term: term term_op factor
     | factor
?factor: factor_op factor
       | power
?power: primary power_op factor
      | primary

?primary: primary DOT name
        | primary call_args
        | primary slice
        | atom

?call_args: OPEN_PAREN [newlines] [call_args_body] CLOSE_PAREN
?call_args_body: call_args_ele [more_call_args] [newlines]
?more_call_args: [newlines] COMMA [newlines] call_args_ele [newlines] [more_call_args]
?call_args_ele: name [newlines] EQUAL [newlines] starred_expr
              | starred_expr

?slice: OPEN_SQUARE [newlines] slice_body [newlines] CLOSE_SQUARE
?slice_body: slice_expr [newlines] [more_slice]
?more_slice: COMMA [newlines] slice_expr [newlines] [more_slice]
?slice_expr: [starred_expr] [newlines] COLON [newlines] [starred_expr] [slice_incr_expr]
?slice_incr_expr: [newlines] COLON [newlines] [starred_expr]

?atom: name
     | true
     | false
     | null
     | string
     | number
     | parens
     | list_or_dict

?parens: OPEN_PAREN [newlines] group [newlines] CLOSE_PAREN

?list_or_dict: OPEN_SQUARE [newlines] [list_or_dict_body] CLOSE_SQUARE
?list_or_dict_body: list_or_dict_body_inner [newlines]
?list_or_dict_body_inner: list_body
                        | dict_body
?list_body: starred_expr [more_list_body]
?more_list_body: [newlines] COMMA [more_list_body_inner]
?more_list_body_inner: [newlines] starred_expr [more_list_body]
?dict_body: starred_expr [newlines] COLON [newlines] starred_expr [more_dict_body]
          | COLON
?more_dict_element: starred_expr [newlines] COLON [newlines] starred_expr
                  | double_star_expr
?more_dict_body: [newlines] COMMA [more_dict_body_inner]
?more_dict_body_inner: [newlines] more_dict_element [more_dict_body]

?number: bin
       | oct
       | hex
       | decimal

?bin: BIN
?oct: OCT
?hex: HEX
?decimal: DECIMAL
?string: D_ML_STRING
       | S_ML_STRING
       | D_SL_STRING
       | S_SL_STRING

?comp_op: single_comp_op | multi_comp_op
?single_comp_op: EQUAL_EQUAL | BANG_EQUAL | LE | LT | GE | GT
?multi_comp_op: not_in | in | is_not | is
?not_in: NOT IN
?in: IN
?is_not: IS NOT
?is: IS
?power_op: STAR_STAR
?factor_op: PLUS | MINUS | TILDE
?term_op: STAR | DIV | DIV_DIV | PERCENT
?sum_op: PLUS | MINUS
?shift_op: LSHIFT | RSHIFT
?band: AMP
?bxor: CARAT
?bor: BAR
?and: AND | DOUBLE_AMP
?or: OR | DOUBLE_BAR
?not: NOT | BANG
?newlines: NEWLINE [more_newline]
?more_newline: NEWLINE [more_newline]
?assignop: EQUAL

?true: TRUE
?false: FALSE
?null: NULL
?name: NAME

?terminator: NEWLINE
           | SEMI_COLON

// Below largly cribbed from https://github.com/lark-parser/lark/blob/master/lark/grammars/python.lark
D_ML_STRING: /([rbtf]{0,4})(""").*?(?<!\\)(\\\\)*?(""")/is
S_ML_STRING: /([rbtf]{0,4})(''').*?(?<!\\)(\\\\)*?(''')/is
D_SL_STRING: /([rbtf]{0,4})("(?!""))(.|\\\r?\n)*?(?<!\\)(\\\\)*?(")/i
S_SL_STRING: /([rbtf]{0,4})('(?!''))(.|\\\r?\n)*?(?<!\\)(\\\\)*?(')/i
BIN: /0[b][01_]+/i
OCT: /0[o][0-7_]+/i
HEX: /0[x][0-9a-f_]+/i
DECIMAL: /(0|[1-9_][0-9_]*)([\.][0-9_]+)?([e]([+-])?((0|[1-9_][0-9_]*)([\.][0-9_]+)?))?([a-z_][a-z0-9_]*)?/i
RETURN: "return"
YIELD: "yield"
CONTINUE: "continue"
BREAK: "break"
LEAVE: "leave"
DEFER: "defer"
TO: "to"
TRUE: "true"
FALSE: "false"
NULL: "null"
DOT: "."
TILDE: "~"
PERCENT: "%"
DIV_DIV: "//"
DIV: "/"
PLUS: "+"
MINUS: "-"
LSHIFT: "<<"
RSHIFT: ">>"
AMP: "&"
CARAT: "^"
BAR: "|"
EQUAL_EQUAL: "=="
BANG_EQUAL: "!="
LE: "<="
LT: "<"
GE: ">="
GT: ">"
OR: "or"
IS: "is"
DOUBLE_BAR: "||"
AND: "and"
DOUBLE_AMP: "&&"
NOT: "not"
BANG: "!"
STAR: "*"
STAR_STAR: "**"
COLON: ":"
EQUAL: "="
IF: "if"
ELIF: "elif"
ELSE: "else"
FOR: "for"
ELFOR: "elfor"
IN: "in"
WHILE: "while"
ELWHILE: "elwhile"
OPEN_PAREN: "("
CLOSE_PAREN: ")"
OPEN_SQUARE: "["
CLOSE_SQUARE: "]"
OPEN_BRACE: "{"
CLOSE_BRACE: "}"
COMMA: ","
SEMI_COLON: ";"
NEWLINE: /\r?\n/
NAME.-1: /[a-z_][a-z0-9_\-]*/i

WS_INLINE: /[ \t\f\v]/
LINE_CONT: /\\[ \t\f\v]*\r?\n/ //cribbed from https://github.com/lark-parser/lark/blob/master/examples/advanced/python2.lark
SL_COMMENT: /#[^\n]*/

%ignore WS_INLINE
%ignore LINE_CONT
%ignore SL_COMMENT

//I'm so annoyed with trying to figure this out, I'm just going to hack it
ML_COMMENT_START: "#*"
ML_COMMENT_END: "*#"
%ignore ML_COMMENT_START
%ignore ML_COMMENT_END

