?start: expr_list

?expr_list: terminated_or_empty_expr [expr_list]
?terminated_or_empty_expr: terminated_expr
                         | empty_expr
?terminated_expr: [properties] expr terminator
empty_expr: terminator
?properties: property [newlines] [more_properties]
?more_properties: property [newlines] [more_properties]
?property: STATIC
         | PUBLIC
         | PRIVATE
         | PROTECTED
         | FINAL
         | CLOSED
         | CONST
         | INIT
         | GET
         | SET

?expr: using_expr [type_expr]

?using_expr: USING [newlines] primary [using_as]
           | exit_expr
?using_as: [newlines] AS [newlines] primary

?exit_expr: exit_type [expr] [exit_direction]
          | assign
?exit_type: RETURN
          | YIELD
          | CONTINUE
          | BREAK
          | LEAVE
          | DEFER

?exit_direction: [newlines] TO [newlines] name

?type_expr: [newlines] COLON [newlines] arith
?assign: primary_assign [type_expr] [newlines] assign_op [newlines] expr
       | group

?group: starred_expr more_group
      | starred_expr
?more_group: [newlines] COMMA [newlines] starred_expr [more_group]
           | COMMA

?starred_expr: single_star_expr
             | double_star_expr
             | structure_decl
?single_star_expr: STAR structure_decl
?double_star_expr: STAR_STAR structure_decl

?structure_decl: fndecl
               | operatordecl
               | classdecl
               | namespacedecl
               | labeled_block
?fndecl: FN [name] [newlines] OPEN_PAREN [newlines] [fnparams] CLOSE_PAREN [type_expr] [newlines] expr
?fnparams: pos_only_params
?pos_only_params: param_eles [newlines] COMMA [newlines] DIV [opt_pos_or_kw_args]
                | pos_or_kw_args
?opt_pos_or_kw_args: COMMA [newlines] pos_or_kw_args
?pos_or_kw_args: param_eles [opt_va_args_kw_only]
               | va_args_kw_only
?opt_va_args_kw_only: COMMA [newlines] va_args_kw_only
?va_args_kw_only: star_param_ele_or_star [opt_param_eles] [opt_kw_va_args]
                | kw_va_args
?star_param_ele_or_star: star_param_ele
                       | STAR
?opt_kw_va_args: COMMA [newlines] kw_va_args
?kw_va_args: double_star_param_ele
?opt_param_eles: COMMA [newlines] param_eles
param_eles: param_ele [more_param_eles]
param_ele: name [type_expr] [param_default]
?more_param_eles: COMMA [newlines] param_ele [more_param_eles]
?star_param_ele: STAR name [type_expr]
?double_star_param_ele: STAR_STAR name [type_expr]
?param_default: [newlines] EQUAL starred_expr
?operatordecl: OPERATOR op [newlines] OPEN_PAREN [newlines] [fnparams] CLOSE_PAREN [type_expr] [newlines] expr

?classdecl: class_type [name] [class_parents] [newlines] block
?class_type: CLASS | STATIC CLASS | TRAIT
?class_parents: [newlines] COLON [newlines] class_parent_ele [more_class_parents]
?more_class_parents: [newlines] COMMA [newlines] class_parent_ele [more_class_parents]
?class_parent_ele: name [class_parent_assign]
                 | classdecl
?class_parent_assign: [newlines] EQUAL [newlines] structure_decl

?namespacedecl: namespace_whole_file
              | namespace_local
?namespace_whole_file: NAMESPACE name [block]
?namespace_local: NAMESPACE [name] block

?label: name COLON [newlines]
?labeled_block: label block
              | block
              | control
?block: OPEN_BRACE [expr_list] CLOSE_BRACE

?control: labeled_control_exprs
        | control_exprs
        | arith
?labeled_control_exprs: label [newlines] control_exprs
control_exprs: if_expr
             | for_expr
             | while_expr
?cond_body: [newlines] expr [elexpr_or_else]
?if_expr: IF expr cond_body
?elif_expr: ELIF expr cond_body

?for_in: expr IN expr
?for_expr: FOR for_in cond_body
?elfor_expr: ELFOR for_in cond_body

?while_expr: WHILE expr cond_body
?elwhile_expr: ELWHILE expr cond_body

?elexpr_or_else: [newlines] elexpr_or_else_real
?elexpr_or_else_real: elexpr | else_expr
elexpr: elif_expr | elfor_expr | elwhile_expr

?else_expr: ELSE [newlines] expr

// This bit is largely cribbed from https://docs.python.org/3/reference/grammar.html
?arith: range
?range: range_start [range_step] [newlines] RANGE [newlines] range_end
      | disjunction
range_step: [newlines] RANGE [newlines] disjunction
range_start: range_start_inner [closed_start_op]
closed_start_op: [newlines] GT
range_start_inner: disjunction
                 | LT
range_end: [closed_end_op] range_end_inner
closed_end_op: LT [newlines]
range_end_inner: disjunction
               | GT
?disjunction: conjunction [newlines] more_disjunction
            | conjunction
?more_disjunction: [newlines] or [newlines] conjunction [more_disjunction]
?conjunction: inversion [newlines] more_conjunction
            | inversion
?more_conjunction: [newlines] and [more_conjunction]
?inversion: not [newlines] inversion
          | comparison
?comparison: bitwise_or [newlines] comp_op [newlines] comparison
           | bitwise_or
?bitwise_or: bitwise_or [newlines] bor [newlines] bitwise_xor
           | bitwise_xor
?bitwise_xor: bitwise_xor [newlines] bxor [newlines] bitwise_and
            | bitwise_and
?bitwise_and: bitwise_and [newlines] band [newlines] shift_expr
            | shift_expr
?shift_expr: shift_expr [newlines] shift_op [newlines] sum
           | sum
?sum: sum [newlines] sum_op [newlines] term
    | term
?term: term [newlines] term_op [newlines] factor
     | factor
?factor: factor_op [newlines] factor
       | power
?power: primary [newlines] power_op [newlines] factor
      | primary

primary_assign: primary [newlines] access
              | atom
primary: primary [newlines] access
        | atom
?access: field_access
       | call_args
       | slice
?field_access: DOT [newlines] name

?call_args: OPEN_PAREN [newlines] [call_args_body] CLOSE_PAREN
?call_args_body: call_args_ele [more_call_args] [newlines]
?more_call_args: [newlines] COMMA [newlines] call_args_ele [more_call_args]
?call_args_ele: pos_arg
              | kw_arg
kw_arg: name [newlines] EQUAL [newlines] starred_expr
pos_arg: starred_expr

?slice: OPEN_SQUARE [newlines] group [newlines] CLOSE_SQUARE

?atom: name
     | true
     | false
     | null
     | self
     | cls
     | super
     | string
     | number
     | parens
     | list
     | dict

?parens: OPEN_PAREN [newlines] expr [newlines] CLOSE_PAREN

list: OPEN_SQUARE [newlines] [list_body] CLOSE_SQUARE
?list_body: list_elements [newlines]
?list_elements: list_element [more_list_elements]
?list_element: starred_expr
?more_list_elements: [newlines] COMMA [newlines] list_element [more_list_elements]
                   | COMMA

?dict: OPEN_SQUARE [newlines] dict_body [newlines] CLOSE_SQUARE
?dict_body: dict_elements
          | COLON
?dict_elements: dict_element [more_dict_elements]
dict_element: starred_expr [newlines] COLON [newlines] starred_expr
?more_dict_elements: [newlines] COMMA [newlines] dict_element [more_dict_elements]
                   | COMMA

?number: bin
       | oct
       | hex
       | decimal

bin: BIN
oct: OCT
hex: HEX
decimal: DECIMAL
string: d_ml_string
      | s_ml_string
      | d_sl_string
      | s_sl_string
d_ml_string: D_ML_STRING
s_ml_string: S_ML_STRING
d_sl_string: D_SL_STRING
s_sl_string: S_SL_STRING

comp_op: single_comp_op | multi_comp_op
single_comp_op: EQUAL_EQUAL | BANG_EQUAL | LE | LT | GE | GT
multi_comp_op: not_in | in | is_not | is | has | of
not_in: NOT IN
in: IN
is_not: IS NOT
is: IS
has: HAS
of: OF
power_op: STAR_STAR
factor_op: PLUS | MINUS | TILDE
term_op: STAR | DIV | DIV_DIV | PERCENT
sum_op: PLUS | MINUS
shift_op: LSHIFT | RSHIFT
band: AMP
bxor: CARAT
bor: BAR
and: AND | DOUBLE_AMP
or: OR | DOUBLE_BAR
not: NOT | BANG
assign_op: EQUAL
dot_op: DOT
array_op: OPEN_SQUARE CLOSE_SQUARE
op: comp_op
  | power_op
  | factor_op
  | term_op
  | sum_op
  | shift_op
  | band
  | bor
  | and
  | or
  | not
  | assign_op
  | array_op
  | dot_op
?newlines: NEWLINE [more_newline]
?more_newline: NEWLINE [more_newline]

true: TRUE
false: FALSE
null: NULL
name: NAME
super: SUPER
cls: CLS
self: SELF

?terminator: NEWLINE
           | SEMI_COLON

// Below largly cribbed from https://github.com/lark-parser/lark/blob/master/lark/grammars/python.lark
D_ML_STRING: /([rbtf]{0,4})(""").*?(?<!\\)(\\\\)*?(""")/is
S_ML_STRING: /([rbtf]{0,4})(''').*?(?<!\\)(\\\\)*?(''')/is
D_SL_STRING: /([rbtf]{0,4})("(?!""))(.|\\\r?\n)*?(?<!\\)(\\\\)*?(")/i
S_SL_STRING: /([rbtf]{0,4})('(?!''))(.|\\\r?\n)*?(?<!\\)(\\\\)*?(')/i
BIN: /0[b][01_]+([a-z_][a-z0-9_]*)?/i
OCT: /0[o][0-7_]+([a-z_][a-z0-9_]*)?/i
HEX: /0[x][0-9a-f_]+([a-z_][a-z0-9_]*)?/i
DECIMAL: /(0|[1-9_][0-9_]*)([\.][0-9_]+)?([e]([+-])?((0|[1-9_][0-9_]*)([\.][0-9_]+)?))?([a-z_][a-z0-9_]*)?/i
OF: "of"
HAS: "has"
USING: "using"
AS: "as"
FN: "fn"
OPERATOR: "operator"
PUBLIC: "public"
PRIVATE: "private"
PROTECTED: "protected"
FINAL: "final"
CLOSED: "closed"
CONST: "const"
INIT: "init"
GET: "get"
SET: "set"
CLASS: "class"
TRAIT: "trait"
STATIC: "static"
NAMESPACE: "namespace"
CLS: "cls"
SELF: "self"
SUPER: "super"
RETURN: "return"
YIELD: "yield"
CONTINUE: "continue"
BREAK: "break"
LEAVE: "leave"
DEFER: "defer"
TO: "to"
TRUE: "true"
FALSE: "false"
NULL: "null"
RANGE: ".."
DOT: "."
TILDE: "~"
PERCENT: "%"
DIV_DIV: "//"
DIV: "/"
PLUS: "+"
MINUS: "-"
LSHIFT: "<<"
RSHIFT: ">>"
AMP: "&"
CARAT: "^"
BAR: "|"
EQUAL_EQUAL: "=="
BANG_EQUAL: "!="
LE: "<="
LT: "<"
GE: ">="
GT: ">"
OR: "or"
IS: "is"
DOUBLE_BAR: "||"
AND: "and"
DOUBLE_AMP: "&&"
NOT: "not"
BANG: "!"
STAR: "*"
STAR_STAR: "**"
COLON: ":"
EQUAL: "="
IF: "if"
ELIF: "elif"
ELSE: "else"
FOR: "for"
ELFOR: "elfor"
IN: "in"
WHILE: "while"
ELWHILE: "elwhile"
OPEN_PAREN: "("
CLOSE_PAREN: ")"
OPEN_SQUARE: "["
CLOSE_SQUARE: "]"
OPEN_BRACE: "{"
CLOSE_BRACE: "}"
COMMA: ","
SEMI_COLON: ";"
NEWLINE: /\r?\n/
NAME.-3: /[a-z_][a-z0-9_]*/i

WS_INLINE: /[ \t\f\v]/
LINE_CONT: /\\[ \t\f\v]*\r?\n/ //cribbed from https://github.com/lark-parser/lark/blob/master/examples/advanced/python2.lark
SL_COMMENT.-2: /#[^\n]*/

%ignore WS_INLINE
%ignore LINE_CONT
%ignore SL_COMMENT

//I'm so annoyed with trying to figure this out, I'm just going to hack it
ML_COMMENT_START.-1: "#*"
ML_COMMENT_END.-1: "*#"
%ignore ML_COMMENT_START
%ignore ML_COMMENT_END

